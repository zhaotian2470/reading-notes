# 概述

## go语言的特征
go语言的特征：
* 语法简单：放弃部分灵活和自由，获取更好的可维护性；
* 并发支持：轻量级的协程；支持CSP并发模型；
* 内存分配：选择tcmalloc：cache给当前协程提供无锁分配，central提供协程之间的内存单元复用，heap管理大块内存；
* 垃圾回收：并发标记、并发清除，极大降低STW时间，尽可能减少对用户协程的影响；
* 标准库：强大的标准库，例如http的支持；
* 工具链：强大的工具链，例如格式化、编译、测试、性能分析等；

# 类型

## 变量和常量
变量和常量的概念：
* 从数学概念来说，变量是可改变的值，常量是可以改变的值；
* 从实现来说，变量是用来存储数据的内存，常量是编译时确定的字符、字符串、数字或者布尔值；

变量和常量的定义和赋值：
* 通常情况下，使用var/const定义；
* 定义常量时，可以使用iota，从而替代枚举：默认情况下iota从0开始，并且不断自增；
* 特定情况下，可以使用简短模式“:=”定义：简短模式的左边有多个值时，至少有一个新值被定义，其它值可能退化为赋值；
* 多变量赋值时，首先计算所有右值，然后再依次完成赋值操作；

## 类型分类
类型的类别：
* 预定义类型
   * 基本类型：bool，byte，int*，uint*，uintptr，float*，complex*, rune，string
   * 聚合类型：array，struct
   * 引用类型：pointer，slice，map，chan，function
   * 接口类型：interface
* 自定义类型：type

赋值函数：
* new：分配零值内存，并返回指针，不关心内部构造和初始化方式，适合值类型；
* make：完成内存分配和相关属性的初始化，适合引用类型；

如下情形的unnamed type可以视为同一类型，并可以通过type修改为named type：
* array：相同元素类型和长度；
* struct：相同字段序列（字段名，字段类型，标签，以及字段顺序）；
* pointer：相同基类型；
* slice：相同元素类型；
* map：相同键值；
* channel：相同数据类型、操作方向；
* function：相同签名（参数和返回值列表，不包括参数名）；
* interface：相同方法集（方法名，方法签名，不包括顺序）；

unnamed type转换规则：
* 所属类型相同；
* 基础类型相同，其中一个是未命名类型；
* 将nil赋值给pointer，slice，map，chan，function，interface；
* channel：数据类型相同，将双向通道赋值给单向通道；
* interface：对象实现了接口；

# 表达式

## 运算符
变量、表达式、语句的使用规则：
* 变量表示一段内存，可作为左值使用；
* 表达式通常作为求值代码，可作为右值或者参数使用；
* 语句完成一个行为，是一段代码块；

指针的说明：
* unsafe.Pointer类似于C语言中的void*，可用来转换指针类型，能安全持有对象；
* uintptr只是一种特殊整型，并不引用目标对象，无法阻止垃圾回收器回收对象；
* 0长度对象的地址是否相等依赖于实现版本，不过肯定不等于nil；

## 流控制
for range语句中，可以讲range的目标看成是函数：
* 会复制range的目标数据；
* 如果range的目标是函数，仅被执行一次；

# 函数

## 参数
值 vs 指针：
* 对于小对象，建议使用值做参数：小对象复制值的代价小；并发编程提倡使用不可变对象，减少数据同步；
* 对于大对象，考虑使用指针做参数：指针做参数时，可能延长目标的生命周期，从栈逃逸到堆，增加垃圾回收的成本；

变参可以理解为传递切片：
* 切片作为变参时，需要展开；
* 切片作为变参时，复制的是切片本身，因此可修改原数据；

## 闭包
* 闭包可以看成是函数、引用环境（例如函数使用的变量）的组合体；
* 闭包通过指针引用环境变量：可能延长变量的生命周期，甚至被分配到堆；具有“延迟求值”的特性（变量的值，不是定义闭包代码时的值，而是闭包代码执行时的值）；

## 延迟调用
延迟调用延迟的是调用，参数值在注册时被复制和缓存；

## 错误处理
* painc向上抛异常，并且不会执行退栈操作；
* recover必须在延迟调用函数中执行，才能正常工作；

# 数据

## 字符串
字符串的特性：
* 字符串包括utf8编码之后的不可变的字节序列；
* rune是int32的别名，用来存储unicode码点，相当于UCS-4/UTF-32编码方式；
* 内置函数len返回字符串的字节数；
* for遍历字符串时，分为byte（普通）和rune（for range）两种方式；

## 数组
go数据是值类型

## 切片
切片的特性：
* 切片通过指针引用底层数据，设定相关属性将数据读写操作限定在指定区域内；
* reslice切片时，新切片不能超过cap，但不受len限制；
* append增加元素时，如超过cap限制，则为新切片对象重新分配数组；
* copy复制数据时，允许切片属于同一底层数组，允许目标区间重叠，复制的长度以较短的切片长度为准；

## 字典
字典的特性：
* 因为内存访问安全和哈希算法的特性，字典被设计为“not addressable”，故不能直接修改value成员；

## 结构体
结构的特性：
* 推荐命名初始化，这样扩充/调整结构字段时，不会导致初始化语句出错；
* 不能将基础字段、指针字段同时潜入为匿名字段；
* 除了接口指针、多级指针外，其它任何命名类型都可以作为匿名字段；
* 字段标签不属于数据成员，但却是类型的组成部分，是用来对字段进行描述的元数据；
* 结构体的内存，是一次分配的。对于引用类型、字符串、指针等，结构内存中只包含其基本（头部）数据；
* 结构体分配内存时，通常以所有字段中最长的基础类型宽度对齐；

## 个人总结
按照是否可以对比，内置的数据类型分为：
* 可以对比：bool，byte，number，string，pointer，chan
* 不可以对比：slice，map，func
* 依赖于成员类型：struct，interface

# 方法

## 方法集
类型有一个与之相关的方法集，决定它是否实现某个接口：
* 类型T的方法集，包含所有receiver T方法；
* 类型*T的方法集，包含所有receiver T+*T方法；
* 匿名嵌入S，类型T的方法集，包含所有receiver S方法；
* 匿名嵌入*S，类型T的方法集，包含所有receiver S+*S方法；
* 匿名嵌入S或*S，类型*T的方法集，包含所有receiver S+*S方法；

## 表达式
方法表达式会还原为普通函数的样式，receiver是第一个参数，调用时需显示传参；
方法值被复制给变量或者作为参数传递时，会立即计算并复制该方法执行所需要的receiver对象，并与其绑定；

# 接口

## 执行机制
在底层实现中，接口的定义如下：
```
type iface struct {
	tab *itab            // 类型信息
	data *unsafe.Pointer // 实际对象指针
}

type itab struct {
	inter *interfaetype        // 接口类型
	_type *_type               // 实际对象类型
	fun   [1]uintptr           // 实际对象方法地址
}
```
只有当两个指针（tab，data）都为nil时，接口才是nil

将对象赋值给接口变量时，会复制该对象。我们无法修改接口存储的复制品，因为它是unaddressable的。
如果想要通过接口修改对象，需要将对象的指针赋值给接口。


# 并发

## 并发的含义
和defer一样，goroutine也会因“延迟执行”而立刻计算并复制执行参数

gosched释放线程去执行其它任务

goexit立即终止整个调用堆栈：return仅退出当前函数；os.Exit不会执行延迟调用；

## 通道
通道底层通过锁来实现，因此性能比锁差

对于closed或nil通道，发送和接收操作的规则：
* closed通道：发送数据panic，接收数据返回已经缓冲的数据或者零值；关闭会panic；
* nil：无论收发都会阻塞；关闭会panic；

select随机选择一个可用通道做收发操作

## 同步
将Mutex作为匿名字段时，相关方法必须实现为pointer-receiver，否则会因复制导致锁机制失效

# 包结构
## 工作空间
几个环境变量的作用：
* GOPATH：编译器等相关工具按GOPATH设置的路径搜索目标，缺省值为$HOME/go；
* GOROOT：指示工具链和标准库的存放为止；
* GOBIN：强制替换工作空间的bin目录；

## 导入包
在使用包之前，需要使用import导入包：
* import导入的是路径，代码中引用成员时使用的是包名；
* 在设置了GOPATH的工作空间中，不能使用相对路径编译；

## 组织结构
初始化：
* go不能保证：同一源文件里面多个初始化函数的执行顺序
* go能够保证：所有初始化函数在单一线程上执行，并且只执行一次

internal vs vendor：
* internal针对内部，vendor针对外部
* 两种目录下的包，都只能被父目录（含所有层次的子目录）访问

## 个人总结
go代码的执行顺序：
* 初始化全局变量
* 初始化函数：init
* main.main

个人猜测编译器等工具搜索目标的顺序：
* vendor目录；
* 标准目录；
* GOPATH或者modules；
* 当前工作空间；

具体参考
```
go help gopath
go help importpath
```

# 反射

## 类型
反射的类型：
* 和C数据结构一样，go对象头部并没有类型指针，通过其自身是无法在运行期获知任何类型相关信息；
* 反射操作需要的全部信息，都源自接口：接口可以转换为反射类型（Type，Value），反射值（Value）可以转换为接口；
* 方法Elem返回指针、通道、数组、切片的基类型；

## 值
反射的值：
* 接口变量会复制对象，并且是unaddressable的，因此想要修改目标对象，就必须使用指针；
* 对于反射包来说，无论是当前包还是外包，都是外包，因此都不能设置非导出字段；

Type vs Kind：
* Type：真实类型；
* Kind：底层类型；

addressable vs setable:
* addressable: 可寻址，通过接口复制之后的很多对象，都是不可寻址的；
* setable: 可修改，对于非导出字段，可以寻址但是不能修改；

## 性能
反射的性能比较差（例如慢100倍），因此不能用于高性能代码；
