# 深入Go语言编译器

经典的编译理论中，一般将编译器分为三个阶段，称为三阶段编译器（three-phase compiler）：
* 前端：扫描解析源程序并进行精准的语义表达；
* 中间阶段：使用多个IR阶段，多种数据结构表示代码，并进行多次优化；
* 后端：生成特定目标机器上的程序；

Go语言编译器的执行流程，可细分为一下阶段：
* 词法解析；
* 语法解析；
* 抽象语法树构建；
* 类型检查；
* 变量捕获；
* 函数内联；
* 逃逸分析；
* 闭包重写；
* 遍历函数；
* SSA生成；
* 机器码生成；

# 浮点数设计原理与使用方法

## IEEE-754浮点数标准
IEEE-754规范使用以2为底的指数表示小数，这和使用以10为底数的指数表示法（即科学记数法）非常类似。
IEEE-754的浮点数存在很多精度，高级语言中一般使用两种精度：
* 32位的单精度浮点数：6-8位精度；
* 64位的双精度浮点数：15-17位精度；

Go语言中的浮点数：
* 既然浮点数不能准确表示十进制数值，为什么Go语言中的fmt.Println能够准确打印：fmt.Println打印之前，先将其转换为最接近的十进制值；
* 加法运算需要进行指数调整，因此存在丢失精度的风险。因此涉及加、减、乘、除运算时，建议优先执行乘除；

## Go语言中的数值
在Go语言中，有几个特殊数值：
* +Inf：正无穷；
* -Inf：负无穷；
* NaN：无效数值；

如果需要高精度计算，可以考虑使用如下库：
* big.Int
* big.Float
* big.Rat

# 类型推断全解析

# 常量与隐式类型转换

## 常量
常量的规范：
* 整数常量：至少存储256位；
* 浮点数常量：至少使用256位保存小数，至少使用16位保存指数；由于溢出无法表示浮点数/复数常量，则报错；由于精度限制无法表示浮点数，四舍五入表示为最接近的常量；

Go语言禁止对常量进行取地址的操作；

## 隐式类型转换
Go语言中，变量之间没有隐式类型转换，不能类型之间只能强制转换。但是编译器可以进行常量和常量、常量和变量之间的隐式类型转换：
* 有类型的优先于无类型的；
* 当两个无类型的进行运算时，结果类型的优先级为：整数（int）< 符文数（rune）<浮点数（float）<复数（imag）

# 字符串的本质与实现

## 字符和字符串
字符和字符串属于两种类型：
字符（rune）：int32的别称，range轮询时的类型为rune；
字符串（string）：不可变的UTF8编码的字节，for循环时的类型为byte；

## 字符串的实现
Go语言使用如下实现表示字符串
```
type StringHeader struct {
	Data uintptr
	Len int
}
```

常量字符串的解析：
* 双引号内的常量字符串，需要计算转义；
* 单撇号内的常量字符串，不需要考虑转义；

字符串的拼接：找到一个空间，可以容纳拼接后的字符串，并且复制原始字符串。

字符串和字节数组的转换：涉及到复制。当字符串大于32个字节时，还需要申请堆内存。


