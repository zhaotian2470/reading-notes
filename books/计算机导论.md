# 基础知识
## 算法在计算机中的作用

## 算法基础

### 插入排序
插入排序的基本思路；对已经有序的数组，每次增加一个元素

### 归并排序
利用分治法解决归并排序：
1. 对于规模为1的数组，直接返回；
1. 使用递归，分别排序前后两部分；
1. 合并排好序的两部分；

## 函数的增长

### 渐进记号
* θ：渐进紧确界，类似==；
* Ο：渐进上界，类似<=；
* ο：非渐进紧确的上界，类似<；
* Ω：渐进下界，类似>=；
* ω：非渐进紧确的下界，类似>；

### 标准记号和常用函数
单调性的相关概念：
* 单调递增，严格递增；
* 单调递减，严格递减；

取整：
* 向下取整：⌊⌋；
* 向上取整：⌈⌉；

模运算：
* (a mod n)等价于(a - n⌊a/n⌋)；
* a≡b(mod n)等价于(a mod n) = (b mod n)；

其它：
* 多重函数$f^{(i)}(n)$：将f(n)重复i次作用到n上；
* 多重对数$log^*n$：$log^*n$ = min{i>=0: $log^{(i)}n$<=1}，多重对数是一个增长非常慢的函数；

几种复杂度：
* 常数；
* 对数；
* 多项式；
* 指数：斐波那契数以指数形式增长；
* 阶乘：$n!=\omicron(n^n)$, $n!=\omega(2^n)$, $lg(n!)=\theta(nlgn)$；

几个常见函数的分析：
* $lnn$：$lnn = 1 + 1/2 + 1/3 + ...$
* $e^x$: $e^x = 1 + x + x^2/2! + x^3/3! + ...$

## 分治法
分治法的三个步骤：
1. 分解：将原问题分解为若干子问题，这些子问题是原问题的规模较小的实例；
1. 解决：递归求解子问题，对于规模足够小的子问题，则直接求解；
1. 合并：将子问题的解合并成原问题的解；

分治法的两种情况：
* 递归情况：子问题规模足够大，需要递归求解；
* 基本情况：子问题规模足够小，不再需要递归；

计算递归式算法渐进界的方法：
* 代入法：猜测一个界，然后用数学归纳法证明；
* 递归树法：将递归式转化为一棵树，其节点表示不同层次的递归调用产生的代价；
* 主方法：求解T(n)=aT(n/b)+f(n)；

主方法求解T(n)=aT(n/b)+f(n)，其中a>=1，b>1:
* 对于某个ε>0，$f(n)=Ο(n^{lg_b{a-ε}})$，则$T(n)=θ(n^{lg_ba})$；
* 对于$f(n)=θ(n^{lg_ba})$，则$T(n)=θ(n^{lg_ba}lgn)$；
* 对于某个ε>0，$f(n)=Ω(n^{lg_b{a+ε}})$，且对于某个常数c<1和所有足够大的n有af(n/b)<=cf(n)，则T(n)=θ(f(n))；

## 概率分析和随机算法
随机算法的概念：
* 随机算法：一个算法的行为，不仅由输入决定，而且也由随机数生成器产生的数值决定；
* 期望运行时间：分析随机算法的运行时间时，我们以运行时间的期望值衡量；
* 指示器随机变量（期望值为事件的可能性）：给定一个样本空间S和事件A，指示器随机变量I{A}定义为：
$$
\{A\}=
\begin{cases} 
1,如果A发生\\
0, 如果A不发生
\end{cases}
$$

几个随机算法：
* 随机排列序列：第i次迭代时，元素A[i]是从元素A[i]到A[n]中随机选取的；

随机算法的几个结论：
* 假设应聘者以随机次序出现，雇佣到最好人员的平均费用为$\Omicron(lnn)$：原因雇佣第一个人的概率为1，第二个人的概率为1/2，第三个人的概率为1/3，因此结果为$lnn = 1 + 1/2 + 1/3 + ...$；
* 假设应聘者以随机次序出现，只雇佣一次得到最好人员的概率为1/e：计算前面n/e的成绩，如果后面的人超过这个成绩则雇佣；
* 生日悖论需要的人数$\Theta(\sqrt{n})$：任何人和另外一个人同一天生日的概率为$1/n$，因此$E[X]=E[\sum_{i = 1}^{k} \sum_{j = i+1}^{k}X_{ij}]=\sum_{i = 1}^{k} \sum_{j = i+1}^{k}E[X_{ij}]=\binom{k}{2}1/n=k(k-1)/2n$；
* 礼券收集需要的张数$nlnn$：收集第i张礼券时的概率为$E[n_i]=n/n-i+1$，$E[X]=E[\sum_{i = 1}^{n}E[n_i]]=\sum_{i = 1}^{n}E[n_i]=\sum_{i = 1}^{n}n/n-i+1=n\sum_{i = 1}^{n}1/i=n(lnn+\Omicron(1))$；
* 特征序列为$\Theta(lg{n})：想要连续n次正面，需要抛$2^n$次$

# 排序和顺序统计量
算  法|最坏情况运行时间|平均情况/期望运行事件
-----|:------------:|----------------:
插入排序|$\Theta(n^2)$|$\Theta(n^2)$
归并排序|$\Theta(nlnn)$|$\Theta(nlnn)$
堆排序|$\Theta(nlnn)$|$\Theta(nlnn)$
快速排序|$\Theta(n^2$)|$\Theta(nlnn)$
计数排序|$\Theta(k+n)$|$\Theta(k+n)$
基数排序|$\Theta(d(k+n))$|$\Theta(d(k+n))$
桶排序|$\Theta(n^2)$|$\Theta(n)$

## 堆排序
堆的特点：
* 除了最底层的元素外，该树是完全充满的，而且是从左到右填充；
* 最小堆/最大堆要求，父节点要小于等于/大于等于子节点；

堆排序的特色：
* 时间复杂度类似归并排序：$\Theta(nlgn)$；
* 空间复杂度类似插入排序：原址排序；

堆排序的过程：
1. 建堆：对于前面一半的元素，需要维护堆的性质；
1. 排序：对调根结点、最后一个节点，将堆减少一个元素，然后维护堆的性质；
维护堆的性质是指：假设子树都是堆，但是根结点不满足要求，则将根结点逐级下沉；

最大优先队列支持如下操作：
* INSERT(S, x)：将元素x插入到堆中（实现方式：先添加到堆的最后，再增加key值）；
* MAXMUM(S)：返回堆的根节点；
* EXTRACT-MAX(S)：删除堆的根节点；
* INCREASE-KEY(S, x, k)：增加key值（实现方式：逐级上浮）；
最小优先级队列的操作，可以类推；

## 快速排序
快速排序的特点：
* 时间复杂度：最坏情况下$\Theta(n^2)$，平均情况下$\Theta(nlnn)$，并且隐含的常数因子特别小；
* 空间复杂度：可以进行原址排序;

快速排序的过程：
1. 选定一个元素，并且分离大于/小于该元素的元素；
2. 对于分离后的数组，进行递归调用；

快速排序的考虑：
* 如何选定元素：选择最后一个/从三个元素（第一个、中间、最后一个）中选择中位数/随机选择元素/五分化的中位数；
* 如何分离元素：和指定元素相等时，是否交换；

## 线性时间的排序
在最坏情况下，任何比较排序算法都需要做$\Theta(nlgn)$次比较，原因：
* 排序的方式数：n!；
* 每次比较可以排除一半的方式；
* 比较数h需要满足：$2^h >= n!$，两边同时lg可以得到：$h>=lg(n!)=\Omega(nlgn)$；

计数排序的思路（假设元素都在0到k的区间内）：
* 循环所有元素：计算每个数值出现的次数；
* 循环所有数值：计算小于或者等于该数值出现的次数；
* 循环所有元素（为了确保稳定，需要从最后一个元素循环到第一个元素）：排序；

基数排序的思路：
* 外层循环（需要从最低有效位开始循环）：基数的每一位；
* 内层循环：计数排序；

桶排序的思路（假设元素均匀分布在区间[0, 1)）中：
* 将[0, 1)区间划分为n个相同大小的桶；
* 循环所有元素：放入桶中；
* 循环桶：排序桶中元素；
* 循环桶：输出桶中元素；

## 中位数和顺序统计量
选择算法：
* 期望线性时间：参考快速排序，但是只需要处理一边；
* 最坏线性时间：参考快速排序，但是只需要处理一边，并且使用5分化中位数的中位数作为划分的主元；

# 数据结构

## 基本数据结构
基本数据结构包括：
* 栈：后进先出；
* 队列：先进先出；
* 链表：有多种变种，例如单向/双向，有/无尾指针，有/无哨兵，是/否循环链表；
* 二叉树：最多两个孩子节点，如果是完全二叉树可以使用堆来表示；
* 分支无限制的有根数：可以使用左孩子右兄弟表示法；

## 散列表
哈希表的要素：
* 散列函数：由关键字计算出槽位；
* 解决冲突的方法；

哈希表的散列函数：
* 除法散列法：$h(k)=k \mod m$，建议m选用一个不太接近2的整数幂的素数；
* 乘法散列法：$h(k)=\lfloor m(kA \mod 1) \rfloor$，m不关键，一般选择为2的整数次幂，Knuth 建议 $A = (\sqrt5 - 1)/2$；
* 全域散列法：从全域函数中随机选择散列函数，使之独立于要存储的关键字；
* 完全散列法：采用两级散列，在每级上采用全域散列，并且二级散列槽位为对应关键字个数的平方；

全域函数的说明：
* 定义：假设$\Eta$为一组有限的散列函数，如果对每一对不同的关键字$k, l \subset U$，满足$h(k)=h(l)$的散列函数$h\subset\Eta$的个数至多为$|\Eta|/m$ ，则$\Eta$叫做全域的；
* 构造：选择足够大的素数p，使得p > k：
  * $\Zeta_p=\{0, 1, ..., p-1\}$；
  * $\Zeta_p^*=\{1, ..., p-1\}$；
  * $h_{ab}(k)=((ak+b)\mod p)\mod m$
  * $\Eta=\{h_{ab}: a \in \Zeta_p^*, b \in \Zeta_p\}$

哈希表解决冲突的办法包括：
* 链接法：在简单均匀的假设下，一次成功/不成功的查找的平均时间为$\Theta(1+\alpha)$，其中$\alpha$为装载因子；
* 开发寻址法：实现
  * 线性探测：存在一次集群的问题，即连续占用的槽不断增加，平均查找时间也随之增加；
  * 二次探测：存在二次集群的问题，即初始位置一样时，探测序列相同；
  * 双重散列：$h(k,i)=(h_1(k)+ih_2(k))\mod m，其中h_2(k)和m互素$；
* 开发寻址法：装载因子为$\alpha$时，在均匀散列的假设下
  * 一次不成功的查找，期望探测次数为$1/(1-\alpha)$；
  * 一次成功的查找，期望探测次数为$1/\alpha \ln(1/(1-\alpha))$；
  * 如果想要删除元素，需要用特定值DELETED代替NIL，对应的查找时间就不仅仅依赖于装载因子；

## 二叉搜索数
二叉搜索数的特点：
* 左子树的节点<=父节点，右子树的节点>=父节点；
* 期望高度为$\Omega(lgn)$，其中n为节点数；

二叉搜索树支持的操作：
* 查找；
* 最小/最大元素；
* 前驱/后继；
* 插入：找到元素需要插入的位置，然后插入；
* 删除：找到元素z后，需要分情况考虑：
  * 如果没有子节点，直接删除z；
  * 如果只有一个子节点，子节点替换原来的节点z；
  * 如果有两个子节点，找到后继y，并让y占据z的位置；

二叉搜索树的工具操作：
* transplant：用一棵子树替换另一棵子树，成为其父节点的孩子节点；

## 红黑树
红黑数数是具有以下特点的二叉搜索数：
* 节点是红色或者黑色；
* 每个节点到所有后代叶节点的简单路径上，具有相同数量的黑色节点；
* 根结点是黑色；
* 红色节点的子节点是黑色；
* 叶子节点（NIL）是黑色；

红黑树支持的操作和二叉搜索树相同，只是一些操作比较复杂：
* 插入：插入红色节点后，需要确保红色节点的子节点不能是红色，因此需要修复（当前节点、父节点为红色，祖父节点为黑色）的情况：
  * 如果叔节点是红色，则将祖父节点的黑色下移，并且递归处理祖父节点；
  * 如果叔节点是黑色，则将自己/父节点上移，并且转换为黑色；
* 删除：删除黑节点后，需要确保具有相同数量的黑色节点，因此需要修复（被删除的节点，当前替换节点都是黑色）情况；
  * 如果兄弟是红色，则兄弟节点取代父节点，新的兄弟将是黑色；
  * 如果兄弟是黑色：
    * 如果兄弟的两个子节点是黑色，则黑色上移；
	* 如果兄弟的左孩子是红色的，则转换为右孩子是红色的情况；
	* 如果兄弟的右孩子是红色，则将兄弟上移，增加黑色节点，解决问题；

红黑树需要用到旋转操作：
* 分类：左旋（右子节点变成新的父节点）/右旋（左子节点变成新的父节点）；
* 时机：
  * 正常情况：使用红色子节点替代根节点；
  * 异常情况：使用黑色子节点替代根节点，导致黑色从一边流向另外一边，可用于添加黑色节点；

## 数据结构的扩张
顺序统计树的特点：
* 顺序统计树是一棵红黑数；
* 顺序统计树增加一个字段：子树的大小；

区间树的特点：
* 区间树是一种红黑树；
* 区间树的key是区间树的最小值，此外还维护其它属性：区间树的最大值，区间；
* 区间树支持的操作：
  * INTERVAL-INSERT(T, x)；
  * INTERVAL-DELETE(T, x)；
  * INTERVAL-SEARCH(Tk, i)；

红黑树的扩张：
* 设f是红黑树T扩张的属性，且假设对任意节点x，f的值仅依赖于节点x, x.left, x.right，x.left.f, x.right.f，那么我们可以在插入和删除操作期间对T进行维护，并且不影响这两个操作的$\Omega(lgn)$渐进时间性能；

# 高级设计与分析技术

## 动态规划
动态规划的特点：
* 时机：使用分治算法时，如果子问题重叠，考虑使用动态规划；
* 实现：
  * 自底向上：如果需要求解所有的子问题，自底向上的算法没有递归开销，因此推荐使用；
  * 自顶向下：缓存子问题结果；
* 典型问题：
  * 钢条切割；
  * 矩阵链乘法；
  * 最长公共子序列；
  * 最优二叉查找树；
 
## 贪心算法
贪心算法的特点：
* 时机：使用分治算法时，如果分解问题的策略可以使用贪心算法；
* 典型问题：
  * 活动选择问题；
  * 分数背包问题；
  * 霍夫曼编码；

## 摊还分析
摊还分析用来计算最坏情况下，每个操作的平均性能：
* 聚合分析：计算n个操作最坏情况下花费的总时间，然后再计算平均代价；
* 核算法：不同操作赋予不用费用，赋予的费用叫做摊还代价
  * 摊还代价=实际代价+信用；
  * 在信用不为负值的情况下，摊还代价能分析出实际代价的最坏情况；
* 势能法：定义一个势函数，确保
  * 摊还代价=实际代价+势函数之差；
  * 在势函数之差不为负值的情况下，摊还代价能分析出实际代价的最坏情况；

## 算法小结
递归算法：
* 分治算法：divide/conquer/combine；
* 贪心算法：类似分治算法，一般用来求解最优化问题，但是分解时使用贪心算法；
* 动态规划：类似分治算法，一般用来求解最优化问题，但是解决阶段重复使用子问题；

概率分析和随机算法：
* 在线雇佣问题：一定雇佣到最优雇员，需要雇佣多少次；一次雇佣可能得到最优雇员的概率；
* 生日悖论；
* 礼券收集者问题；
* 特征序列；

# 高级数据结构

## B树
B树的特点：
* 每个节点保存属性：
  * 是否叶节点；
* 每个非叶保存属性：
  * 关键字的个数（度数）的限制：除了根结点外，每个节点关键字个数$[t-1, 2*t-1]$，对应的孩子数为$[t, 2*t]$
* 每个叶节点具有相同的高度；

B树支持的操作：
* 搜索；
* 插入关键字：
  1. 如果根节点是满节点，则上面挂空根节点；
  1. 向下查找关键字，碰到满节点则分裂；
  1. 插入关键字；
* 删除关键字：
  * 当前节点为内部节点，并且关键字不在当前节点中，在进入对应子节点之前需要确保对应子节点的度数至少为t：
    * 如果相邻的子节点有度数大于或者等于t，则从相邻子节点借用；
	* 如果相邻的子节点度数都为t-1，则和相邻子节点合并；
  * 当前节点为内部节点，并且关键字在当前节点中：
    * 如果前面/后边子节点有度数大于或者等于t，则删除对应的前驱/后继，并用它替代关键字；
    * 如果两个子节点度数都为t-1，则将要删除的节点、两个子节点合并，并在新节点中删除关键字；
  * 当前节点为叶节点，则直接删除；

B+数：B数的变种，内部节点只存放关键字和孩子指针，因此最大化内部节点的分支因子

B树的分析：
* 适用场景：数据量太大，需要保存到速度很慢的硬盘；
* 基本原理：增加每个节点的分支（分支数有固定上限），从而减少高度；

## 斐波那契堆
斐波那契堆的特点：
* 最小堆序的有根树的集合；
* 根链表：所有有根树组成一个环形的双向链表；
* 孩子链表：所有有孩子组成一个环形的双向链表；
* 堆保存属性：
  * 最小节点；
  * 节点树；
* 每个节点保存属性：
  * 度数（degree）；
  * 标识（mark）：上一次成为另外节点的孩子后，是否失去过孩子；

斐波那契堆支持的操作：
* 插入一个节点；
* 寻找最小节点；
* 合并；
* 抽取最小节点：
  * 将子节点变成根结点后，删除该节点；
  * 合并相同度数的节点，并清除被合并节点的mark；
* 关键字的减值：
  * 如果节点是根结点，或者减值后没有违反堆序，直接返回；
  * 如果违反堆序，则将该节点设置为根节点，并且级联切断父节点：如果父节点已经设置mark，则切断父节点；否则设置父节点mark；
* 删除一个节点：将节点的值设置为$-\infty$，然后抽取最小节点；

斐波那契堆的分析：
* 适用场景：堆需要合并；
* 基本原理：限制度数，而不是高度；
* $D(n) = \Omega(lgn)$：其中n表示节点的个数，D(n)表示度数；

## van Emde Boas树
van Emde Boas树的特点：
* 取值范围大于2时，节点包括以下：vEB(u)表示取值范围为u的van Emde Boas树
  * summary：指向一棵树，$vEB(\lceil\sqrt{u}\rceil)$；
  * data：指向$\lceil\sqrt{u}\rceil$棵树，$vEB(\lfloor\sqrt{u}\rfloor)$；
  * min：最小元素，不出现在data中；
  * max：最大元素，重复出现在data中；
* 取值范围为2时，只需要min，max；
`
van Emde Boas树的基本操作：
* 查找最小/最大元素；
* 判断一个值是否在集合中；
* 查找后继/前驱：以后继为例说明
  * 处理基准情况：取值范围为2；
  * 处理非基准情况：
    * 如果小于min，直接返回min；
	* 根据元素的高位，找到对应data节点最大值，从而判定是在该data节点查找，还是使用后继data节点的最小值；
* 插入元素：
  * 处理基准情况：如果没有元素，直接设置最小/最大值；
  * 处理非基准情况：
    * 确认是否需要对调min；
	* 如果取值范围大于2：如果summary没有对应元素则在summary插入元素；在data插入元素；
	* 确认是否需要修改max；
* 删除元素：
  * 处理基准情况：
    * 只有一个元素，直接修改最小/最大值；
	* 取值范围为2，最小/最大值相同；
  * 处理非基准情况：
    * 确认是否需要对调min；
	* 在data删除元素；
	* 如果data中没有元素，则删除summary中对应元素；
	* 确认是否需要修改max；

van Emde Boas树的分析：
* 适用场景：给取值范围较小的集合，提供更好的性能（很多操作性能为$\Omicron(lglgu)$，其中u为取值范围）；
* 基本原理：增加每个节点的分支（分支数最多为$\sqrt{u}$），从而减少高度；；

## 用于不相交集合的数据结构
支持的操作：
* MAKE-SET(x)：建立一个新集合，包含唯一元素x；
* UNION(x, y)：合并集合x，y；
* FIND-SET(x)：查找元素x的代表；

典型实现是使用不相交集合森林，并且使用以下优化：
* 按秩合并；
* 路径压缩；

典型实现的性能分析：最坏情况的运行时间为$\Omega(m\alpha(n))$，其中$\alpha(n)$大多数情况下小于或者等于4，正式的定义如下：
$$ \alpha(n)= \begin{cases}
	0, 对 0<= n <= 2 \\[2ex]
	1, 对 n = 3 \\[2ex]
	2, 对 4<= n <= 7 \\[2ex]
	3 对 8<= n <= 2047 \\[2ex]
	4, 对 2048<= n <= A_4(1) ，A_4(1) >> 10^{80} \\[2ex]
	\end{cases} $$

# 图算法

## 基本的图算法
图的表示：
* 邻接链表法：适合于稀疏图，无向图链表节点的数量为2|E|；
* 链接矩阵法：适合于稠密图，无向图是一个对称矩阵；

广度优先搜索的实现：
* 将节点分成三类：白色（未知节点，还未处理）；灰色（介于未知/已知之间，正在处理中）；黑色（已知节点，处理完毕）；
* 使用队列处理所有节点：刚开始时全部节点为白色，并且将一个节点放入队列，并设置为灰色；处理队列节点时，将白色子节点放入队列，然后将当前节点设置为黑色；

广度优先算法的作用：
* 计算无权最短路径；

深度优先搜索的实现：
* 将节点分成三类：白色（未知节点，还未处理）；灰色（介于未知/已知之间，正在处理中）；黑色（已知节点，处理完毕）；
* 记录节点的两个时间戳：发现时间（涂上灰色）；结束时间（涂上黑色）；

深度优先搜索可以生成深度优先森林$G_\pi$：
* 对有向图来说，对应的边有：树边；前向边；后向边；横向边；
* 对无向图来说，对应的边有：树边；后向边；

深度优先算法的作用：
* 判断有向图是否有环：有后向边；
* 拓扑排序：结束时间倒序；
* 计算强连通分量（任意一对节点u,v，都可以相互到达）：
  实现：首先深度优先搜索；然后将边反向，按照之前搜索结果v.f逆序再次深度优先搜索；
  原理：分量图（强连通图压缩成一个节点）应该是有向无环图；

## 最小生成树
最小生成树算法：
* kruskal算法（增加边）：按照权重从低到高的次序检查每一条边，如果该边没有构成回路，则加入到集合；
* prim算法（增加节点）：所有不在树中的节点，记录和树中节点的权重排序，每次使用权重最小的边；


## 单源最短路径
单源最短路径算法：
* 广度优先搜索：适合无权；
* Dijkstra：属于贪心算法，适合没有负权重的图
  * 实现：选择路径最小节点，执行松弛操作；
* floyd-warshall：属于动态规划算法，适合没有负环路的图
  * 实现：循环$|G.V|-1$轮，每轮循环所有边，在其上执行松弛操作；检查对于每一条边，是否满足三角不等式；
* floyd-warshall的简化版本: 适合有向无环图
  * 实现：拓扑排序后，按照顺序只循环一轮，在所有边上做松弛操作；

单源最短路径的基础操作：
* 松弛操作：如果存在情况$v.d>u.d+w(u,v)$，则将u作为v的前置，并且设置$v.d=u.d+w(u,w)$；
* 是否满足三角不等式：$v.d<=u.d+w(u,v)$；

单源最短路径算法，可以用来求解“差分约束系统”问题：
* 构造虚拟节点$v_0$：到每个节点长度为0；
* 构造边$w(v_i, v_j)=b_k$：如果存在$v_j-v_i<=b_k$；
* 节点$v_0$到其它节点的最短路径长度，就是差分约束系统的解；

## 所有节点对的最短路径问题
所有节点对的最短路径算法：
* 自底向上计算最短路径权重：动态规划，扩充边
  * 扩充边：对于每一个节点对，计算$min(l_{ik}+w_{kj})$，其中$1<=k<=n$，$l_{ik}$表示之前的最短路径，$w_{kj}表示权重$；
  * 简单方法：每次扩充一条边；
  * 重复平方：每次扩充的边数翻倍；
* 自底向上计算最短路径权重(floyd-warshall)：动态规划，扩充点
  * 扩充点：对于每一个节点对，计算$min(d^{(k-1)}_{ij}, d^{(k-1)}_{ik}+d^{(k-1)}_{kj})$，其中$1<=k<=n$，$d^{(k-1)}_{ij}$表示之前的最短路径；
  * 简单方法：每次扩充一个点；
* Johnson算法：改进dijkstra算法，适合稀疏图
  * 通过重新赋予权重，保证每条边的权重非负：
    * 构造虚拟节点s，并且确保s到每个节点的权重为0，h(v)表示s到v的最小值，则$h(v)<=h(u)+w(u,v)$，则对于新权重都非负：$w(u,v)+h(u)-h(v)$；
  * 每一对节点使用dijkstra算法，计算最短路径；

## 最大流
流网络的特点：
* 每条边有非负的流量值，并且如果存在容量c(u,v)，则不存在c(v,u)；
* 存在两个特殊节点：源节点/汇节点；

流网络的扩充：
* 如果存在反平行边，则新增一个节点：一条边的流量全部经过该节点，另外一条边的流量全部不经过该节点；
* 多源/多汇节点：构造一个超级源/超级汇，所有源/所有汇都从超级源发起/超级汇结束；
* 最大二分匹配：可以变成一个多源/多汇节点问题；

最大流的实现：在残存网络中找到增广路径
* 残存网络：以流网络为初始网络，每次找到增广路径后，将流量反转；
* 增广路径：可以是从源到汇的任意路径，建议使用最短路径（假设每条边权重相同）；

# 算法问题选编

## 多线程算法
概念：
* 静态线程：操作系统线程，由于创建/销毁的代价较大，因此大多数应用长期维持着，因此称为“静态”；
* 动态多线程：程序员只描述应用中的并行性，并发平台维护线程，几乎都支持两个特征：
  * 嵌套并行：派生一个子过程，调用者/子过程同时执行；
  * 并行循环：循环中的迭代，可以并发执行；
* 计算有向无环图：多线程计算看成一个有向无环图
  * 顶点：一系列指令；
  * 边：并行关系，可以分为：连接边、派生边、调用边，返回边；
  * 如果图中有一条从u到v的链，则它们是串行的，否则是并行的；

定律：
* 工作量定律：$T_P>=T_1/P$；
* 持续时间定律：$T_P>=T_\infty$；
* 集中式的在线调度器，如果使用贪心算法则有：$T_P<=T_1/P+T_\infty$；

## 矩阵运算
矩阵运算的求解：
* 对一个矩阵A做LUP分解后，方便求解方程$Ax=b$：$PA=LU$；
* 矩阵求逆运算，等价于矩阵乘法运算；

最小二乘逼近：给定一组数据进行多项式曲线拟合，要求误差是最小二乘解，则存在$c=((A^TA)^{-1}A^T)y=A^+y$，其中
* 伪逆矩阵为：$((A^TA)^{-1}A^T)=A^+$；

## 线性规划
线性规划的类别：
* 标准型线性规划：满足线性不等式约束的一个线性函数的最大化
  * 表述：满足约束$Ax<=b$, $x>=0$的情况下，求$C^Tx$的最大值；
  * 转换方式：
    * 目标函数可能是最小化，而不是最大化：目标函数乘以负值；
	* 可能有变量不具有非负约束：使用两个相减的非负变量替换；
	* 可能有等式约束：使用两个不等式来替换；
	* 可能有大于或者等于的不等于约束：不等式乘以负数；
* 松弛型线性规划：满足线性等式约束的线性函数的最大化
  * 表述：所有的变量约束都是非负，所有的表达式约束都是等式；
  * 将标准型线性规划的约束条件$Ax<=b$变成：该约束条件的每一个约束引入一个非负变量，从而组成$x_{n+i}=b_i-\Sigma_{i=1}^m a_{ij}x_i$；

线性规划的解决：
* 单纯形算法（从某个点开始，逐步向最优解移动）：能快速解决一般的线性规划，但是对于刻意仔细设计的输入，需要指数时间；
  * 先将约束转换为标准形，然后再转换为松弛型；
  * 如果存在基本可行解，则使用基本可行解；如果不存在基本可行解，则引入新变量$x_0$，并且求满足如下情况的$-x_0$的最大值：$Ax-x_0<=b$，对于任意的$x_i>$非负；
  * 转动获取更大的目标值：选取一个非基本变量和一个基本变量，，然后替换两者的角色；
* 椭球算法：多项式算法，但是实际效果比较差；
* 内点法：多项式时间算法；
* 线性规划的拓展：如果有要求所有的变量取整数值，则问题变成NP难；

线性规划的例子：
* 最短路径问题：表达式约束是小于或者等于；目标值约束是最大值；
* 最大流：容量表达式约束是小于或者等于，流量约束是等于，目标值约束是最大值；
* 最小费用流：容量表达式约束是小于或者等于，流量约束是等于，目标值约束是最小值；

## 字符串匹配
字符串匹配的定义：
* 文本：$T[1..n]$，其中$T_k$表示$T[1..k]$；
* 模式：$P[1..m]$，其中$P_k$表示$P[1..k]$；
* 连接：$|x|+|y|$；
* 前缀：$w\subset x$表示w是x的前缀；
* 后缀：$w\supset x$表示w是x的后缀；

字符串匹配算法：
* 朴素字符串匹配算法：两层循环，外层迭代文本T，内层迭代模式P；
* KPM（Knuth-Morris-Pratt）算法：迭代文本T，如果不匹配则前移匹配指针
  * 计算模式P的前缀函数：$\pi [q]=max\{k: k<q且P_k \supset P_q，k<q\}$；
  * 迭代文本T：如果不匹配则前移匹配指针；如果匹配则前移匹配指针、文本；

## NP完全性
问题类概念：
* P类问题：多项式时间内可以解决的问题；
  * P类问题的其它表述形式：多项式时间内可以被算法判定；多项式时间内可以被算法接受；
* NP类问题：多项式时间内可以被证明的问题；
  * NP累问题的其它表述形式：可以在多项式时间内验证证书；
  * 按照定义，P类问题都属于NP类问题；
  * NP类问题，适用于判定问题，但是可以转换为最优化问题；
* NPC类问题：如果一个NP问题和其它任何一个NP问题一样不易解决，就称该问题为NPC类问题；

语言概念：假设都是判定问题，即输入是由0/1组成的串，输出是0/1
* 算法A接受串x：对于给定的输入x，算法输出$A(x)=1$；
* 算法A拒绝串x：对于给定的输入x，算法输出$A(x)=0$；
* 算法A接受语言L：算法A接受语言L中的任何串；
  * 算法A在多项式时间内接受语言L：算法A在多项式时间内接受**语言L中的任何串**；
* 算法A判定语言L：算法A接受/拒绝任何串，如果算法A陷入死循环则不算判定；
  * 算法A在多项式时间内判定语言L：算法A在多项式时间内判定**任何串是否属于语言L**；

NPC问题的例子：
* 电路可满足性问题；
* 顶点覆盖问题：找出最小规模的顶点，覆盖所有边；
* 哈密顿回路问题：找出通过所有顶点的回路；
* 旅行商问题：费用最低的哈密顿回路；
* 子集和问题：给定正整数的有限集S和一个整数目标t，找到子集$S^{'}$，使得其元素和为t；

## 近似算法
近似算法的概念：
* 近似解代价：C；
* 最优解代价：$C^*$；
* 近似比$\rho = max\{C/C^*, C^*/C\}$；
* 近似算法：如果一个近似算法的近似比为$\rho(n)$，则称该算法为$\rho(n)$近似算法；
* 近似模式：对于任意$\{\varepsilon: \varepsilon > 0\}$，该模式都有一个$1+\varepsilon$的近似算法；
* 多项式近似模式：对于任意$\{\varepsilon: \varepsilon > 0\}$，近似模式都以多项式时间运行；
* 完全多项式近似模式：对于任意$\{\varepsilon: \varepsilon > 0\}$，近似模式都以用$1/\varepsilon$和n的多项式时间运行；

近似算法的例子：
* 集合覆盖问题：使用贪心算法，每次选择覆盖最多元素的集合；
* 顶点覆盖问题：迭代每一条边，取对应边的两个顶点，并且删除对应顶点的边；
* 满足三角不等式的旅行商问题：计算最小生成树；按照先序遍历最小生成树，并且确保不要重复遍历节点；
* 一般旅行商问题：如果P!=NP，则对任何常数$\rho >= 1$，一般旅行商问题不存在具有近似比为$\rho$的多项式时间近似算法；
* 子集和问题：
  * 迭代子集元素：每次迭代开始时，元素翻倍；删除部分元素，例如元素值比上一个元素的差值不大于$\varepsilon/2n$，元素值大于目标t；
  * 返回最大元素；

随机化近似算法的概念：
* 随机解的期望代价：C；
* 最优解代价：$C^*$；
* 随机化的近似比$\rho = max\{C/C^*, C^*/C\}$；
* 随机化的$\rho(n)$近似算法：能达到近似比为$\rho(n)$的随机化算法；

随机化近似算法的例子：
* 给定MAX-3-CNF可满足性问题的一个实例，它有n个变量和m个子句，将每个变量都以1/2的概率设置为0/1的随机化近似算法，是一个随机化的8/7近似算法；

线性规划近似算法的例子：
* 顶点覆盖问题：使用线性规划求解以下问题，并且取顶点值>=1/2的顶点
  * 对每一条边，两个顶点的权重和大于或者等于1；
  * 对于每一个顶点，权重取值范围为$[0, 1]$；
  * 目标值：带权重的顶点和最小；
